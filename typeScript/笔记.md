typescript
  语法更严格，更简洁
  无法直接运行，需要转换为js运行

一、优点
  提供类型系统：增强了代码的可读性和可维护性，在编译阶段就能发现大部分错误。
  支持ES6
  强大的IDE支持：类型检测、语法提示

二、安装环境
  npm install typescript -g
  tsc -v查看版本
  tsc -h帮助
  tsc 选项 ts文件路径 //编译生成js文件 es6会转译成es5
  tsc --outDir ./js first.ts//生成的文件放在哪个文件夹里面

  tsconfig.json
    包含tsconfig.json文件的目录为一个独立的ts项目
    可以在tsconfig.json中设置编译器选项，如转换规则，输出目录等
    在项目根目录下执行：tsc --init 可以进行ts项目的初始话，会自动生成tsconfig.json文件

  自动监视编译项目（热部署）：
    在ts项目根目录下执行：tsc -w -p tsconfig.json,对项目开启自动监视编译项目
    在vscode中执行：终端-》运行任务-》tsc监视tsconfig.json

三，注意事项
  1.定义的变量名是全局注册的，有可能与window的变量名冲突
    使用export{}将文件声明为一个模块 将作用域变为块状作用域
  2.对模板字符串内的中文会转成unicode编码`姓名${name}`


四、语法
  1、变量
    var/let/const 变量名:数据类型 = 变量值；
    增加了数据类型的限制
    如果定义变量时未指定类型，而是直接赋值，则以初次复制的数据类型作为变量的类型
    如果定义变量时只声明，未赋值，也没指定类型，则变量的类型为any

    主要为开发者在开发阶段，提供了限制变量类型限制的功能

  2、数据类型
    ts除了支持js的数据类型外，还扩展了一些类型
    js：string,number,array，boolean，null，undefined，Object
    ts新增：元组，枚举enum，any，void，never

    1.Array
    //方式1：在数据类型后面加[]
    let names:string[] = ['12','123']
    //方式2：使用数组的泛型，Array<数据类型>
    let nums:Array<number> = [1,2,3]

    2.null，undefined
    默认情况下null和undefined是所有类型的子类型，可以将null和undefined赋值给其它类型（非严格情况（"strict": false））

    3.元组,特殊的数组，限制数量和每个元素的类型
      let tuple:[number,string,boolean] = [1,'set',false] 

    4.枚举enum 可以指定可供选择的列表，限定取值范围
      enum Season {
        spring = '春',//每个成员有两部分组成；名称和值
        summer = '夏',//每个成员有两部分组成；名称和值
        autumn = '秋',//每个成员有两部分组成；名称和值
        winter = '冬',//每个成员有两部分组成；名称和值
      }
      let s:Season = Season.spring //春

    5.any 任意类型，暂时不确定变量类型时
      let a:any;

    
    6.void 空类型 取值只能为null或者undefined，某种程度上与any相反
      //一般不会将变量声明为void
      //通常当函数没有返回值时，会声明返回值为void
      function show(): void{
        console.log(123)
      }

    7.//never 表示永不存在的类型,永远没有终点
      function test(): never{
        while (true) {
          
        }
      }

    8.//Object 表示非原始类型 除基础类型外
      let d:Object = {}


    9.联合类型 可以是几种类型之一 不能是其它
      let e:string|number = 123
      e = 'qwe'

    10.类型断言
      //获取变量的长度（数值没有长度会报错）
      //方式一 <类型>值
      //方式2 使用as ：值 as 类型
      // if ((<string>f).length) {
      //   console.log((f as string).length)
      // }

3.函数
  1.
    //1.调用函数时参数的数量，类型必须一致
    //2.未指定类型时，参数默认为any类型
    function jiangshan(a:number,b:number,c:string) {
      return a+b
    }
    //可选参数
    //1.使用问号表示参数可选
    //2.必选参数不能放在可选参数后面
    function f2(a:string,b?:number) {
      
    }
    f2('sdd')

  2.
    //默认参数
    //1.直接等号表示默认值
    function f3(a:string,b:number=8) {
      
    }

  3.
    //剩余参数
    //1.参数个数任意，可以有多个，也可以没有
    //2.使用...定义剩余数据，类型为数组，会将传入的所有参数放在数组里
    function f4(a:string,...b:any[]) {
      
    }

  4.
    //为返回值定义类型
    //1.在（）后指定返回的类型
    //2.没有返回值时，用void
    function f5(): string{
      return 'ser'
    }
    function f6(): void{
    }

  5.
    //函数类型
    //定义一个变量f7，类型为函数，函数的参数类型为string，返回值为布朗
    // let f7: (a: string) => boolean
    // f7 = function (a: string):boolean {
    //   return true
    // }
    let f7: (a: string) => boolean = function (a: string):boolean {
        return true
      }


4.类
  class
  1.class Student{
      name:string='234';
      age:number=134;
      show() {
        console.log(this.name+this.age)
      }
      calc(num1: number, num2: number):number{
        return num1 + num2
      }
    }
    let stu1 = new Student()
    let stu2 = new Student()
    stu1.name = '123'
    stu1.show()
    stu2.show()

  2.class Student{
      name:string;
      age: number;
      constructor(name:string,age: number) {
        this.name = name
        this.age  = age
      }
      show() {
        console.log(this.name+this.age)
      }
      calc(num1: number, num2: number):number{
        return num1 + num2
      }
    }
    let stu1 = new Student('123',1234)
    let stu2 = new Student('11223',123124)
    stu1.show()
    stu2.show()

  3.继承
    class Student1 extends Student{
      grade: number;
      constructor(name:string,age: number,grade?:number) {
        super(name, age)
        this.grade = grade?grade:0
      }
      show1() {
        console.log(this.grade)
      }
    }
    var stu11 = new Student1('12', 123)
    stu11.show1()


5.修饰符
  //实例属性
  public（公开）：可以再任何地方访问
  protected（受保持）：可以在当前类和子类中访问，在类的外部无法访问。
  private（私有）：只能在当前类中访问。


  class Person{
    name: string;//默认就是public
    protected age: number = 123
    private sex:string = '男'
    constructor() {
      this.name = '123'
    }
    show() {
      console.log(this.age)
      console.log(this.sex)
      console.log(this.name)
    }
    private show1() {
      console.log(this.age)
      console.log(this.sex)
      console.log(this.name)
    }
  }
  let p = new Person()
  p.show();
  // p.show1();//报错
  // console.log(p.age)//报错
  // console.log(p.sex)//报错

  class PersonC extends Person{
    constructor() {
      super()
      // console.log(this.sex) //报错
    }
  }


6.封装
  将类的属性封装在类中，不允许在类的外部直接访问，保护数据的安全。
  只能通过被授权的方法才能对数据进行访问，被称为存取器getters/；setters

  步骤：
    1.将属性私有化
      使用private修饰属性，命名一般以_开头
    2.提供对外访问的方法，用于对属性进行取值和赋值
      取值 get 新属性名(){控制私有属性取值}
      赋值 set 新属性名(新值){控制私有属性赋值}
    3.访问新属性，实际上就是在对私有属性进行操作
      取值 对象名.属性名
      赋值 对象名.属性名 = 新值
  本质上是使用 defineProperty进行数据劫持

  class fengzhuang{
    private _sex: string = '12123'
    //存取器
    get sex() {
      return this._sex
    }
    set sex(value) {
      //可以控制值 写方法 比如只能输入男
      this._sex = value
    }
  }
  let fz = new fengzhuang()
  fz.sex = 'sad'
  console.log(fz.sex)

  
  //静态属性 属于整个类
  static
  类名.属性名 不能通过实例访问


7.抽象类
  不能被new 实例化 只用于继承
  使用关键字abstract
    abstract class animal{
      name: string;
      constructor(name: string) {
        this.name = name
      }
    }
    class Dog extends animal{
      constructor(name: string) {
        super(name)
      }
    }
    // let an = new animal()//报错
    let dog = new Dog('str')

  抽象方法
    abstract cry():any;
    子类必须重写cry方法

  特性：
    1.抽象类中可以有抽象方法，也可以没有
    2.含有抽象方法的类，必须为抽象类
    3.子类继承抽象类后，必须重写抽象类中所有的抽象方法，佛则子类仍然未抽象类
